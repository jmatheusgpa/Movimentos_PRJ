---
title: "Projeto Final "
author: "José Matheus"
date: "29/05/2020"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
```


```{r libraries}
# install.packages("tidyverse")
# install.packages("tidytext")
# install.packages("stargazer")
# install.packages("ggthemes")

# install.packages("htmlwidgets") 
library(htmlwidgets) #str_view()
library(ggthemes)

library(tidyverse)

library(tidytext)

library(stargazer)

library(knitr)

```


## Extraindo informações de processos de recuperação judicial

Versão 6, lendo dados de movimentação atualizados pelo professor (03/08/20)

#### 1. Gerar um relatório reproduzível em R

#### 2. Explicar brevemente os objetivos da análise

Queremos usar o R para extrair dados de processos de recuperação judicial. A recuperação judicial é um processo onde a empresa em dificuldades financeiras entra na justiça para renegociar as dívidas com seus credores e obter um prazo maior para pagamento. Caso a maioria dos credores não concorde com o pedido da empresa, aí a recuperação judicial é transformada em falência.

Usaremos estes dados para estimar os efeitos de uma possível reforma da Lei de Falências usando um modelo de barganha, conforme parte do abstract do meu projeto de pesquisa:

>"A reforma da Lei de Falências Brasileira de 2005 teve impactos positivos na oferta de crédito (Araujo et al., 2012) e investimento das firmas (Ponticelli e Alencar, 2016). Contudo, atrasos (Sacramone et al., 2017) e baixas taxas de recuperação (Jupetipe et al., 2017) marcam os procedimentos atuais. Dado esse cenário desmotivador, existe uma discussão de reforma em andamento no Brasil. Esta destina-se a, dentre outras coisas, estimular financiamentos para empresas em recuperação judicial e priorizar as reivindicações fiscais em caso de reorganização das firmas. Nosso objetivo é contribuir para tal discussão ao estimar o modelo estrutural de Dou et al. (2019) para fricções em falências. Em particular, trataremos dos efeitos da reforma sobre excesso de liquidação/reorganização, duração dos acordos e taxas de recuperação. Consequentemente, nosso projeto também contribui para a literatura de desenho ótimo de falências e estimação de jogos não cooperativos."

Para estimar esse modelo, precisamos saber de algumas datas importantes no processo de recuperação judicial:

1) Quando a empresa deu entrada no processo
2) Quando a empresa teve ou a sua recuperação judicial aprovada (homologação do plano) ou recusada, daí a recuperação é convolada em falência
3) Quanto tempo demorou, em média, entre as reuniões de credores para decidir o que fazer com a firma.

Neste trabalho vamos extrair os dados 1) e 2). O dado 3) é um pouco mais complicado de conseguir, pretendo fazer depois.


Por que usar mineração de dados? O principal motivo é tornar os resultados da pesquisa mais reproduzíveis. Se eu coletasse os dados manualmente (olhando cada movimento de cada processo), seria muito custoso para outra pessoa verificar os resultados da minha pesquisa Contudo, se eu faço isso por meio de códigos, basta verificar os códigos ao invés de centenas de processos.

Outros motivo (não menos importante): fazer a análise assim é muito mais divertido.

A principal desvantagem de usar o R neste caso é que alguns dados podem ser classificados erroneamente. Para isso, preciso pensar em mais testes para verificar a consistência deles.


#### 3. Abrir pelo menos um banco de dados externo, ou montar um banco de dados original

Vou montar um banco de dados original a partir dos dados já extraídos da internet fornecidos pelo meu orientador.

Usaremos dados da movimentação de 274 processos de recuperação judicial que eu já havia analisado manualmente antes para determinar quando se encerraram.

Tais dados foram extraídos pelo meu orientador, Dr. Rafael Ferreira, que me enviou para determinar essas datas importantes de cada processo. A base de dados contém as seguintes colunas:

* fullMatch e linkToPdf: são colunas geradas no processo de extração dos dados. Não usaremos aqui.

* date: a data na qual a movimentação (decisão, decreto, ato ordinário, dentre outras) no processo aconteceu

* movimento: qual o tipo de movimento que aconteceu: se foi uma decisão, se foi uma publicação de edital, se foi declarada a falência da empresa, dentre outros

* detalhes: o texto que está na movimentação do caso. É analisando esta coluna que vamos determinar quando aconteceram as principais movimentações.

* id: coluna de identificação usada na extração dos dados. Não usaremos aqui.

* processo: número do processo de recuperação judicial. Cada número de processo é único. Há várias movimentações para cada processo.



```{r leitura dos dados}

movs_df <- readRDS("movs_resumidos_03082020.RDS")



#são 272 processos diferentes que já foram finalizados
movs_df %>%
  select(processo) %>%
  distinct() %>%
  nrow()


#deixando tudo em letra minúscula ####

movs_df <- movs_df %>% 
  mutate(detalhes = tolower(detalhes))

#removendo acentos das palavras. ####
#Consultei esta função em: https://pt.stackoverflow.com/questions/46473/remover-acentos

rm_acento <- function(str,pattern="all") {
  # Rotinas e funções úteis V 1.0
  # rm.accent - REMOVE ACENTOS DE PALAVRAS
  # Função que tira todos os acentos e pontuações de um vetor de strings.
  # Parâmetros:
  # str - vetor de strings que terão seus acentos retirados.
  # patterns - vetor de strings com um ou mais elementos indicando quais acentos deverão ser retirados.
  #            Para indicar quais acentos deverão ser retirados, um vetor com os símbolos deverão ser passados.
  #            Exemplo: pattern = c("´", "^") retirará os acentos agudos e circunflexos apenas.
  #            Outras palavras aceitas: "all" (retira todos os acentos, que são "´", "`", "^", "~", "¨", "ç")
  if(!is.character(str))
    str <- as.character(str)
  
  pattern <- unique(pattern)
  
  if(any(pattern=="Ç"))
    pattern[pattern=="Ç"] <- "ç"
  
  symbols <- c(
    acute = "áéíóúÁÉÍÓÚýÝ",
    grave = "àèìòùÀÈÌÒÙ",
    circunflex = "âêîôûÂÊÎÔÛ",
    tilde = "ãõÃÕñÑ",
    umlaut = "äëïöüÄËÏÖÜÿ",
    cedil = "çÇ"
  )
  
  nudeSymbols <- c(
    acute = "aeiouAEIOUyY",
    grave = "aeiouAEIOU",
    circunflex = "aeiouAEIOU",
    tilde = "aoAOnN",
    umlaut = "aeiouAEIOUy",
    cedil = "cC"
  )
  
  accentTypes <- c("´","`","^","~","¨","ç")
  
  if(any(c("all","al","a","todos","t","to","tod","todo")%in%pattern)) # opcao retirar todos
    return(chartr(paste(symbols, collapse=""), paste(nudeSymbols, collapse=""), str))
  
  for(i in which(accentTypes%in%pattern))
    str <- chartr(symbols[i],nudeSymbols[i], str)
  
  return(str)
}


movs_df <- movs_df %>% 
  mutate(detalhes = rm_acento(detalhes))


#agora todos os dados estão na forma minúscula e sem acentuação
#exemplo1: "Assembléia" virou "assembleia"
#exemplo2: "Recuperação" virou recuperacao


#criando a variável chave de cada observação na coluna id_linha 
# É apenas um número dizendo qual a linha no banco de dados original

movs_df <- movs_df %>% 
  mutate(id_linha = seq(n()))


#ajustando o  formato de data para facilitar contas adiante
movs_df <- movs_df %>% 
  mutate(date = as.Date(date, format="%Y-%m-%d"))

         
```



#### 4. Manipular, transformar e limpar os dados para atender os objetivos



```{r dificuldades}

numero_movimentos <- movs_df %>% 
  distinct(movimento) %>% 
  nrow()

descr_movimentos <- movs_df %>% 
  distinct(movimento) %>% pull() %>% sort()


#quais são os movimentos que contém "falência"?
# descr_movimentos[str_detect(descr_movimentos, "(f|F)alência")]


mov_concedida <- movs_df %>% 
  filter(movimento == "Concedida a recuperação judicial")
```

##### Dificuldades 

A principal dificuldade é que esses dados não foram feitos para serem usados em pesquisas acadêmicas. Prova disso é que as movimentações dos processos não têm um padrão. Por exemplo, há `r numero_movimentos`  textos possíveis para classificar a movimentação ocorrida. Isto dificulta sabermos as datas de movimentações importantes dos processos. 


Outro exemplo, se filtrarmos para o movimento "Concedida a recuperação judicial", teremos apenas `r mov_concedida %>% nrow()` observações, quando na verdade boa parte dos `r movs_df %>% distinct(processo) %>% nrow()` processos analisados deveria ter um movimento desses.

Diante disso, podemos procurar expressões que facilitem a nossa procura pelas datas-chave dos processos.

##### Método usado no projeto

O método que usei nesse projeto foi:

1) filtrar os casos que já tinham a classificação correta, por exemplo, "Concedida a recuperação judicial"

2) analisar os textos dos casos encontrados procurando expressões que os juízes usassem sempre
    + a maior parte dessa análise foi manual, lendo os processos mesmo
    + tentei tokenizar os textos e até procurar as palavras mais distintas entre as movimentações. Contudo, não achei os resultados disso tão úteis (deixei o código em rascunho, caso queira verificar)
    
3) busquei as expressões encontradas em 2) e verifiquei se tinham alguma inconsistência óbvia
  
4) organizei a data de cada evento para os processos nos quais encontrei dados

```{r funções}

#função para dizer se um processo possui um padrão de texto que eu procurei
procura <- function(dados, padrao){
  
  
  #dados é uma base de dados que contenha uma coluna com texto chamada "detalhes"
  #padrao é o texto que buscamos
  
  filter(dados, str_detect(string = tolower(detalhes),
                       pattern = padrao))
  
}


#função para dizer se um processo NÂO possui um padrão de texto que eu procurei
procura_nao <- function(dados, padrao){
  
  
  #dados é uma base de dados que contenha uma coluna com texto chamada "detalhes"
  #padrao é o texto que buscamos
  
  filter(dados, !(str_detect(string = tolower(detalhes),
                       pattern = padrao)))
  
}

#função para resumir os textos encontrados
resumo <- function(dados, numero, string){
  
  #vamos repartir o string de detalhes usando str_sub
  #start é um pouco antes de a primeira vez que o string apareceu
  #end é um pouco depois que o string apareceu
  #assim, o string procurando fica bem no meio do texto
  start <- dados$detalhes[numero] %>% str_locate(string)
  start <- max(0, start[[1]]-400)
  
  end <- start + 800
  
  return(str_sub(dados$detalhes[numero], start, end))
  
}




#função para resumir os textos encontrados, em forma vetorial
resumo_vetor <- function(dados, string){
  
  #vamos repartir o string de detalhes usando str_sub
  #start é um pouco antes de a primeira vez que o string apareceu
  #end é um pouco depois que o string apareceu
  #assim, o string procurando fica bem no meio do texto
  start <- dados$detalhes %>% str_locate(string)
  start <- start[,1]
  
  end <- str_length(dados$detalhes)
  
  return(str_sub(dados$detalhes, start, end))
  
}



#função para procurar padrão e já resumir os dados encontrados em uma nova coluna chamada "detalhes_resumo"
procura_resume <- function(data, string){
  
  #procura o padrão e cria uma nova coluna com o resumo 
  #o resumo é baseado no padrão
  
  data %>% 
  procura(string) %>% 
  mutate(detalhes_resumo = resumo_vetor(., string))
  
  
  
}

#função para ler texto da coluna "detalhes" procurando por id_linha

detalhes_id_linha <- function(x){
  
  movs_df %>% filter(id_linha == x) %>% pull(detalhes)
}

```

##### Data inicial
A data inicial de cada procedimento de recuperação inicial será a data de quando a empresa fez o requerimento da recuperação judicial. A nossa proxy para isso é a data da primeira movimentação oficial no caso.

OBS: Rascunhos foram deixados nos chunks com as opções eval=FALSE, include=FALSE, apenas para mostrar outras alternativas tentadas antes de chegar ao resultado final.

```{r primeira movimentação}
#vamos extrair a data da primeira movimentação de cada processo
#essa é nossa proxy para a data de requerimento de RJ


primeira_mov <- movs_df %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


#vamos construir a lista de todos os processos,servirá para checar o dado de quantos processos nós conseguimos
lista_processos <- primeira_mov %>% 
  distinct(processo) %>% 
  arrange(processo)


#a partir de agora, procuraremos as outras datas relevantes e vamos fazer left_join na tabela datas_rj
#não precisaremos mais dos casos onde não há links para pdf, então vamos filtrar
movs_df_completo <- movs_df


movs_df <- movs_df %>%
  filter(str_detect(linkToPdf, ""))

#vamos remover também as movimentações que são do tipo Edital, pois estas contém textos de decisões passadas

#pega todos os movimentos que começam com "Edital"
filtro_edital <-  descr_movimentos[str_detect(descr_movimentos, "^(E|e)dital")]

movs_df <- movs_df %>% 
  filter(!(movimento %in% filtro_edital))


```




```{r deferimento da RJ, eval=FALSE, include=FALSE}

#deixei essa parte de lado porque o deferimento da recuperção judicial é uma das etapas iniciais
#então não demora muito tempo entre a primeira movimentação e o deferimento

pattern_defiro <- c("defiro o processamento da recuperacao judicial",
                    "processamento deferido") %>% paste(collapse = " | ")•


hom_def <- movs_df %>% 
  procura_resume(pattern_defiro)


#o que acontecia? às vezes um documento posterior citava trechos da decisão. 
#Por exemplo, publicavam um edital dizendo que a decisão citou "blablablablabla" no dia tal e tal.
#isso é comum em documentos do tipo Edital ou Certidão de Objeto e Pé, que registram o andamento dos processos
#parece então que podemos resolver o problema pegando apenas a primeira movimentação de cada grupo


hom_def <- hom_def %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()

#isso garante que teremos no máximo uma observação para cada processo
# hom_def %>% group_by(processo) %>%
#   tally() %>%
#   filter(n>1)



#fazendo o mesmo para o artigo 52

pattern_art52 <- c("artigo 52",
                    "art. 52") %>% paste(collapse = "|")

hom_art52 <- movs_df %>% 
  procura(pattern_art52) %>%
  procura_resume("administrado(r|ra)") 


# str_view(c("administradora judicial", "administrador judicial"), "administrado(r|ra) judicial")

#fazendo o mesmo tratamento de remover entradas duplicadas
hom_art52 <- hom_art52 %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()

hom_art52_prj <- hom_art52 %>% 
  procura_resume("assembleia")


```

##### Data de aprovação/rejeição do plano

A outra etapa importante é a data quando o plano de recuperação judicial é aprovado ou rejeitado. Para o plano ser aprovado, 1) ou ele não deve ter sofrido objeção dos credores ou 2 ele pode ter sofrido objeção, mas ter sido aprovado pela maioria dos credores em assembleia geral. Se o plano for rejeitado, a recuperação judicial é transformada em falência (o termo técnico "convolada em falência") .

OBS: Na continuação desse projeto, vou buscar quais casos sofreram objeção e quais foram as datas das assembleias gerais de credores. Se tiver alguma dica para isso, é muito bem vinda.

```{r homologação do plano - filtro}

#primeiro, vamos tentar filtrar pela movimentação para ver quantos casos existem
hom_filtro <- movs_df %>% 
  filter(movimento == "Concedida a recuperação judicial")


#fazendo um ngram para procurar as palavras mais comuns
#não fazemos filtro com stopwords porque queremos as expressões tais como estão escritas no texto
#e não tiramos as stopwords do texto porque queremos filtrar expressões regulares, não fazer a tokenização


hom_filtro_ngram <- hom_filtro %>% unnest_tokens(ngram, detalhes,
                                       token="ngrams", n=3) 

#filtrando palavras com poucas letras
# hom_filtro_ngram %>%
#   filter(str_length(ngram)>3) %>% 
#   group_by(ngram) %>% 
#   tally() %>% 
#   top_n(100, n) %>% 
#   arrange(n)

pattern_hom_filtro <- c("plano de recuperacao",
                        "negativas de debitos",
                        "em recuperacao judicial") %>% paste(collapse = " | ")


hom_pattern_filtro <- movs_df %>%
  procura_resume("plano de recuperacao") %>% 
  filter(!str_detect(detalhes, "a contar"))


```
No caso da aprovação (homologação) do plano, identifiquei que os juízes usualmente falam "concedo a recuperação judicial" em suas decisões. Fiz um filtro baseado nesse critério. Aprovação, homologação do plano e concessão da recuperação judicial são sinônimos no contexto desse projeto.

Um problema que acontece é que às vezes um documento cita trechos de decisões anteriores. Então se buscarmos "concedo a recuperação judicial", apareceria mais de uma movimentação para alguns processos. A primeira é a data da aprovação do plano de fato, enquanto a segunda movimentação apenas cita a primeira. A solução para isso foi filtrar apenas as primeiras movimentações encontradas para cada processo.

Além disso, em alguns casos eu procurei por artigos específicos da Lei de Falências de 2005 (Lei Nº 11.101/2005) para guiar a pesquisa. No caso das homologações, procurei pelo Artigo 58, que cita as hipóteses nas quais os juiz pode homologar o plano:

> "Art. 58. Cumpridas as exigências desta Lei, o juiz concederá a recuperação judicial
do devedor cujo plano não tenha sofrido objeção de credor nos termos do art. 55 desta Lei ou
tenha sido aprovado pela assembleia-geral de credores na forma do art. 45 desta Lei"

```{r homologação - expressões}

#regulado pelo artigo 58

#o que acontecia? às vezes um documento posterior citava trechos da decisão. 
#Por exemplo, publicavam um edital dizendo que a decisão citou "blablablablabla" no dia tal e tal.
#isso é comum em documentos do tipo Edital ou Certidão de Objeto e Pé, que registram o andamento dos processos
#parece então que podemos resolver o problema pegando apenas a primeira movimentação de cada grupo

#por algum motivo tem que ser (igo|.), se não o regex não funciona direito
hom_art58 <- movs_df %>% 
  procura_resume("art(igo|.) 58") %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


linhas_hom_art58 <- nrow(hom_art58)
#não retornou muitas linhas. Tem 106 observações, dentre elas algumas que são de decretação de falência

#decretação de falência costuma citar o artigo 99 da LRF. Então vamos limpar todas as entradas que citarem este artigo. Outro artigo citado em falência é o artigo 104

hom_art58 <- hom_art58 %>%
  filter(!str_detect(detalhes, "art(igo|.) 99| art(igo|.) 104"))
  


#analisando os textos manualmente, vemos que as expressões "concedo a recuperação judicial", "o plano deve ser homologado" e "homologacao do plano de recuperão judicial aprovado" são comuns. (Tentei filtrar palavras-chave assim fazendo a tokenização do texto, mas não funcionou tanto quanto eu gostaria)

pattern_homol <- c("concedo a recuperacao judicial", "o plano deve ser homologado","o plano de recuperacao judicial deve ser homologado", "homologo o plano", "fica homologada a recuperacao judicial","fica homologado o plano de recuperacao judicial","o plano de recuperacao deve ser homologado", "concedo recuperacao judicial") %>% paste(collapse = "|")


hom_homol <- movs_df %>% 
  procura_resume(pattern_homol) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()






hom_art61 <- movs_df %>%
  procura_resume("art(igo|.) 61") %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()
  

#artigo 57 também é bastante citado na concessão de recuperações judiciais, pois fala da dispensa de certidão negativa de débitos

#muitas vezes o juiz cita o artigo 57 mais de uma vez: as primeiras vezes para cobrar as certidões ao credor e a última na sentença de concessão da recuperacão judicial.
#assim, vamos filtrar a ÚLTIMA movimentação na qual o juiz citou artigo 57 em cada processo (lógica diferente dos demais casos)



hom_art57 <- movs_df %>% 
  procura_resume("art(igo|.) 57") %>% 
  arrange(processo, desc(date)) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


#tentando com a palavra suspensao. Resultado não foi promissor porque ela também é usada em decretação de falência e também quando a empresa faz o requerimento da recuperação judicial
# hom_suspensao <- movs_df %>% 
#   procura_resume("suspensao")
# 
# hom_suspensao <- hom_suspensao %>% 
#   arrange(processo, date) %>% 
#   group_by(processo) %>% 
#   slice(1) %>% 
#   ungroup()




#vou colocar mais um filtro, usando artigo 73 (hipóteses para convolação em falência), junto do artigo 99 (sentença de decretação de falência).

#filtro primeiro casos que foram de falência, depois casos de foram convolados em falência pelo art 73

#vamos filtrar casos do artigo 73 pelos incisos:
#iii quando o plano é rejeitado em assembleia geral dos credores
#ii quando a empresa não apresenta o plano
#a ideia é NÃO pegar casos do inciso iv, quando a falência é decretada porque a empresa não cumpriu plano
hom_art_99_73 <- movs_df %>%
  procura_resume("art(igo|.) 99") %>%
  procura_resume("73, inc(iso|.) ii | 73, inc(iso|.) iii | 73, iii | 73, ii") %>%
  arrange(processo, desc(date)) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()




#art 45 trata dos critérios para aprovar plano de recuperação em assembleia geral de credores
#se tiver art 45 + art 99, provavelmente a decretação de falencia tem a ver com rejeição do plano
hom_art_99_45 <- movs_df %>%
  procura_resume("art(igo|.) 99") %>%
  procura_resume("art(igo|.) 45") %>%
  arrange(processo, desc(date)) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()




#juntando as bases de dados sobre homologação e removendo dados duplicados
#neste caso, vão ficar os dados das primeiras bases que eu colocar
#assim, eu priorizo os dados nos quais eu tenho mais certeza de estarem corretos
#achei este código mais limpo que o rascunho no chunk abaixo
hom <- hom_filtro %>% 
  bind_rows(hom_homol, hom_art58, hom_art57, hom_art_99_73) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


#com quantos processos eu fico com a data se remover art 58?
hom2 <- hom_filtro %>% 
  bind_rows(hom_homol, hom_art_99_73) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()

hom <- hom2 %>% 
  select(processo, date, detalhes, detalhes_resumo, id_linha) %>% 
  rename(data_hom = date,
         detalhes_hom = detalhes,
         detalhes_hom_resumo = detalhes_resumo,
         id_linha_hom = id_linha)



check_58 <- hom_art58 %>% 
  anti_join(hom, by = "processo")

#e se fizer com a última movimentação do artigo 58?

hom_art582 <- movs_df %>% 
  procura_resume("art(igo|.) 58") %>% 
  arrange(processo, desc(date)) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup() %>% 
  filter(!str_detect(detalhes, "art(igo|.) 99| art(igo|.) 104"))


check_582 <- hom_art582 %>% 
  anti_join(hom, by = "processo")

#checando art 57

check_57 <- hom_art57 %>% 
  anti_join(hom, by = "processo")

#depois: fazer anti_join do hom_art_99_45




```

```{r testando novas expressoes para homologacao}

pattern_homol2 <- c("conceder a recuperacao judicial") %>% paste(collapse = "|")


hom_homol2 <- movs_df %>% 
  procura_resume(pattern_homol2) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()

check_homol2 <- hom_homol2 %>% 
  anti_join(hom, by = "processo")
#não ficou muito bom

pattern_homol3 <- c("homologo\\s*(.*?)\\s* plano de recuperacao") %>% paste(collapse = "|")

padroes_exemplo <- c("homologo, para que surtam seus regulares efeitos, o plano de recuperacao judicial", "homologo o novo plano de recuperacao judicial")

str_view_all(padroes_exemplo, pattern_homol3)

hom_homol3 <- movs_df %>% 
  procura_resume(pattern_homol3) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()

check_homol3 <- hom_homol3 %>% 
  anti_join(hom, by = "processo")

```






```{r homologação - juntando dados, eval=FALSE, include=FALSE}

#preparando dados para join


j_hom_filtro <- hom_filtro %>%
  select(processo, date) %>%
  rename(data_filtro = date)
  
j_hom_homol <- hom_homol %>%
  select(processo, date, detalhes_resumo) %>%
  rename(data_homol = date,
         detalhes_resumo_homol = detalhes_resumo)

j_hom_art58 <- hom_art58 %>%
  select(processo, date, detalhes_resumo) %>%
  rename(data_art58 = date,
         detalhes_resumo_art58 = detalhes_resumo)
  
j_hom_art57 <- hom_art57 %>%
  select(processo, date, detalhes_resumo) %>%
  rename(data_art57 = date,
         detalhes_resumo_art57 = detalhes_resumo)

hom_dados <- lista_processos %>% 
  left_join(j_hom_filtro, by = "processo") %>% 
  left_join(j_hom_homol, by = "processo") %>% 
  left_join(j_hom_art58, by = "processo") %>% 
  left_join(j_hom_art57, by = "processo") 
  

#pega dados prioritariamente de hom_homol, se não tiver dados, aí usa a do filtro
# se não tiver no filtro também, usa o artigo 58

hom_dados <- hom_dados %>% 
  mutate(data_homogacao = data_homol) %>% 
  mutate(data_homogacao = case_when(is.na(data_homogacao)~ data_filtro,
                                    TRUE~ data_homogacao)) %>% 
  mutate(data_homogacao = case_when(is.na(data_homogacao)~ data_art58,
                                    TRUE~ data_homogacao)) %>% 
  mutate(data_homogacao = case_when(is.na(data_homogacao)~ data_art57,
                                    TRUE~ data_homogacao)) 

#quantos processos ainda faltam?
#tínhamos 120 NAs usando homol e filtro
#foi para 106 NAs colocando os dados do artigo 58
#foi para 93 quando adicionamos artigo 57
 # sum(is.na(hom_dados$data_homogacao))

```





```{r checagem de dados, eval=FALSE, include=FALSE}
#temos duas bases de dados com mais de 250 observações que julgamos serem as datas de homologação dos planos de recuperação judicial

#vamos fazer um left_join dessas datas com os números de processo. E ver em quais casos elas diferem
#nos casos em que são iguais, teremos mais confiança de que se trata de fato da data de homologação


#pegando a lista dos processos para fazer a checagem
lista_processos <- movs_df %>% 
  select(processo) %>%
  distinct() %>% pull()

cronograma <- tibble(processo = lista_processos)

#organizando agora a tabela hom_def
join_hom_def <- hom_def %>% 
  select(processo, date, detalhes_resumo) %>% 
  rename(data_def = date,
         detalhes_resumo_def = detalhes_resumo)

cronograma <- cronograma %>% 
  left_join(join_hom_def, by = "processo")

#organizando a tabela hom_art52

join_hom_art52 <- hom_art52  %>% 
  select(processo, date, detalhes_resumo) %>% 
  rename(data_art52 = date,
         detalhes_resumo_art52 = detalhes_resumo)

cronograma <- cronograma %>% 
  left_join(join_hom_art52, by = "processo")

#agora fazendo  a diferença entre os dois casos. Usamos a funçõa difftime, pois o formato de datas é inglês

cronograma <- cronograma %>% 
  mutate(dias_def_hom = difftime(data_def,data_art52, units = "days"))



#vamos ver os casos ok
cronograma_ok <- cronograma %>% 
  filter(dias_def_hom == 0) %>% 
  filter(!(is.na(dias_def_hom)))

#fazendo join já com datas_rj para motivar
datas_rj <- datas_rj %>% 
  left_join(cronograma_ok, by = "processo")

#dias entre requerimento e a homologação do plano
datas_rj <- datas_rj %>% 
  mutate(dias_req_hom = difftime(data_art52, data_requerimento, units = "days"))


#vamos ver os casos para verificar
cronograma_verificar <- cronograma %>% 
  filter(!(dias_def_hom == 0))

```







```{r objeções, eval=FALSE, include=FALSE}

#rascunho para o próximo passo do projeto
#agora queremos ver quais casos tiveram objeções dos credores

#as objeções são reguladas pelos artigos 55 e 56

pattern_artsobj <- c("artigo 55", "art. 55", "artigo 56", "art. 56") %>% paste(collapse = " | ")

obj_arts <- movs_df %>% 
  procura_resume(pattern_artsobj) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()

obj <- movs_df %>% 
  procura_resume("objec") %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()
  

hom_art58 <- movs_df %>% 
  procura_resume(pattern_art58) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


obj <- movs_df %>% 
  procura("apresentou objecao")






```






```{r trigam para recuperação judicial, eval=FALSE, include=FALSE}
#removendo as stopwords
# stopwords <- get_stopwords(language="pt") %>%
#   rename(palavra=word)


mov_concedida <- movs_df %>% 
  filter(movimento == "Concedida a recuperação judicial")

mov_concedida_trigams <- mov_concedida %>% unnest_tokens(trigram, detalhes,
                                       token="ngrams", n=3)

# mov_concedida_trigams <- mov_concedida_trigams %>% 
#   separate(trigram, c("palavra1", "palavra2", "palavra3"), sep=" ") %>% 
#   anti_join(stopwords, by=c("palavra1"="palavra")) %>%
#   anti_join(stopwords, by=c("palavra2"="palavra")) %>%
#   anti_join(stopwords, by=c("palavra3"="palavra")) %>%
#   unite("trigram", c(palavra1, palavra2, palavra3), sep=" ", remove=F)

mov_concedida_trigams <- mov_concedida_trigams %>%
  mutate(documento = "mov_concedida") %>% 
  select(trigram, documento)

#quais movimentos contém a expressão "Decretação"?

# movs_df %>% distinct(movimento) %>% filter(str_detect(string = movimento,"Decretação"))


#faremos o mesmo processo acima
#Decretação do Encerramento da Recuperação Judicial
mov_encerramento <- movs_df %>% 
  filter(movimento == "Decretação do Encerramento da Recuperação Judicial")

mov_encerramento_trigams <- mov_encerramento %>% unnest_tokens(trigram, detalhes,
                                       token="ngrams", n=3)

# mov_encerramento_trigams <- mov_encerramento_trigams %>% 
#   separate(trigram, c("palavra1", "palavra2", "palavra3"), sep=" ") %>% 
#   anti_join(stopwords, by=c("palavra1"="palavra")) %>%
#   anti_join(stopwords, by=c("palavra2"="palavra")) %>%
#   anti_join(stopwords, by=c("palavra3"="palavra")) %>%
#   unite("trigram", c(palavra1, palavra2, palavra3), sep=" ", remove=F)

mov_encerramento_trigams <- mov_encerramento_trigams %>%
  mutate(documento = "mov_encerramento") %>% 
  select(trigram, documento)





#Decretação de falência

mov_falencia <- movs_df %>% 
  filter(movimento == "Decretação de falência")

mov_falencia_trigams <- mov_falencia %>% unnest_tokens(trigram, detalhes,
                                       token="ngrams", n=3)

# mov_falencia_trigams <- mov_falencia_trigams %>% 
#   separate(trigram, c("palavra1", "palavra2", "palavra3"), sep=" ") %>% 
#   anti_join(stopwords, by=c("palavra1"="palavra")) %>%
#   anti_join(stopwords, by=c("palavra2"="palavra")) %>%
#   anti_join(stopwords, by=c("palavra3"="palavra")) %>%
#   unite("trigram", c(palavra1, palavra2, palavra3), sep=" ", remove=F)

mov_falencia_trigams <- mov_falencia_trigams %>%
  mutate(documento = "mov_falencia") %>% 
  select(trigram, documento)


#agora vamos preparar os documentos

mov_concedida_prep <- mov_concedida_trigams %>% 
  group_by(trigram, documento) %>% 
  tally() %>% 
  ungroup()


mov_encerramento_prep <- mov_encerramento_trigams %>% 
  group_by(trigram, documento) %>% 
  tally() %>% 
  ungroup()


mov_falencia_prep <- mov_falencia_trigams %>% 
  group_by(trigram, documento) %>% 
  tally() %>% 
  ungroup()


#juntando tudo

mov_distintas <- mov_concedida_prep %>% 
  bind_rows(mov_encerramento_prep, mov_falencia_prep)

#finalmente, a análise das expressões mais distintas


mov_distintas_idf <- mov_distintas %>% bind_tf_idf(trigram, documento, n)

mov_distintas_idf %>% 
  group_by(documento) %>% 
  top_n(20, tf_idf)

#concedida
#lei nº 13.043
#nº 13.043 14


#encerrada
#artigo 63
#decreto o encerramento

#falencia
#artigo 99
#sp informar
```

##### Datas de finalização do processo de recuperação judicial

As últimas datas que procurei foram as de encerramento do processo de recuperação judicial (RJ). O destino final de uma RJ ou é encerramento da recuperação (empresa se recuperou) ou é falência.

Elas não são essenciais ao projeto de pesquisa. Pesquisei porque 1) são interessantes e 2) os textos das decisões finais podem ajudar na próxima etapa de extração dos dados (após concluir a matéria).


```{r finalização da RJ}
#o destino final de uma RJ ou é encerramento da recuperação (empresa se recuperou) ou é falência
#faremos duas bases diferentes porque queremos diferenciar estes dois casos
#depois a gente junta essas bases 

#neste bloco nós usaremos movs_df_completo, pois tem algumas decisões de encerramento que não possuem link para pdf

#o filtro para encerramento da recuperação judicial funcionou muito bem,
#ao todo são 66 casos de recuperação, já analisei isto manualmente antes.

enc_filtro <- movs_df_completo %>% 
  filter(movimento == "Decretação do Encerramento da Recuperação Judicial") %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()



#uma expressão que vi bastante foi "decreto o encerramento da recuperacao judicial"
#adicionei também "declaro encerrada a recuperacao judicial"
pattern_enc <- c("decreto o encerramento da recuperacao judicial", "declaro encerrada a recuperacao judicial") %>% paste(collapse = "|")



enc_decreto <- movs_df_completo %>% 
  procura_resume(pattern_enc) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


#o artigo 63 fala quando o juiz pode decretar o encerramento da RJ
# pattern_art63 <- c("artigo 63",
#                     "art. 63") %>% paste(collapse = "|")
# 
# 
# enc_art63 <- movs_df_completo %>% 
#   procura_resume(pattern_art63) %>% 
#   procura("administrado(r|ra)") %>% 
#   procura_resume("saldo") %>% 
#   arrange(processo, date) %>% 
#   group_by(processo) %>% 
#   slice(1) %>% 
#   ungroup()

#juntando as bases de dados sobre encerramento e removendo duplicatas
enc <- enc_filtro %>% 
  bind_rows(enc_decreto) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()

#preparando os dados para bind
enc <- enc %>% 
  mutate(resultado = "encerrou RJ com êxito") %>% 
  select(processo, date, resultado, detalhes, detalhes_resumo, id_linha)



#filtro para movimentos classificados como falência

filtro_falencia <- c("Decretação de falência","Decretada a Falência - Sentença Completa", "Decretada a Falência - Sentença Resumida")

dec_filtro <- movs_df_completo %>% 
  filter(movimento %in% filtro_falencia) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


#uma expressao que aparece bastante é "decreto a falencia".
#também há casos em que o ministério público decreta a falência e em seguida o juiz se refere a ele dizendo que este "decretou a falencia"
#também existe a opção de o juiz falar "convolo a recuperacao judicial em falência"

dec_falencia <- movs_df_completo %>% 
  procura_resume("decret(o|ou) a falencia| convolo a recuperacao judicial em falencia| defiro o pedido de convolacao da recuperacao judicial em falencia") %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()

#tentei pegar tudo "defiro (...) convolacao" caso o juiz fale 'defiro a convolação", mas só tem uma obs
# teste <- "defiro o pedido de convolacao da recuperacao judicial em falencia"
# 
# 
# dec_falencia2 <- movs_df_completo %>%
#   procura_resume("decreto \\s*(.*?)\\s*a falencia") %>%
#   arrange(processo, date) %>%
#   group_by(processo) %>%
#   slice(1) %>%
#   ungroup()



#artigo 99

#ao invés de decreto, convolo, etc, procurar "falida" ajuda a separar os casos que foram falencia mesmo
#o juiz sempre manda suspender ações de cobrança contra a "falida"
dec_art99 <- movs_df_completo %>% 
  procura_resume("art(igo|.) 99") %>%
  # filter(!str_detect(detalhes, "decreto | convolo")) %>% 
  procura_resume("falida") %>%
  # procura_resume("decreto | decretou | convol(o|ou) | convolar") %>%
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


#juntando os filtros
dec <- dec_filtro %>% 
  bind_rows(dec_art99, dec_falencia) %>% 
  arrange(processo, date) %>% 
  group_by(processo) %>% 
  slice(1) %>% 
  ungroup()


#preparando os dados para o bind
dec <- dec %>% 
  mutate(resultado = "falência") %>% 
  select(processo, date, resultado, detalhes, detalhes_resumo, id_linha)


final <- enc %>% 
  bind_rows(dec) %>% 
  rename(data_final = date,
         detalhes_final = detalhes,
         detalhes_final_resumo = detalhes_resumo,
         id_linha_final = id_linha)

#checando se há dados duplicados
# final_duplicado <- final %>% 
#   group_by(processo) %>% 
#   tally() %>% 
#   filter(n>1) %>% pull(processo)
# 
# #haviam aparecido 5 casos duplicados, vou olhar um a um
# 
# final %>% 
#   arrange(processo) %>% 
#   filter(processo == final_duplicado[2])
# 
# enc %>% filter(processo == final_duplicado[2]) %>% pull(detalhes)
# dec %>% filter(processo == final_duplicado[2]) %>% pull(detalhes)
#olhei os casos e realmente é confuso. Nesse caso, por exemplo, existe uma decisão na qual o juiz decreta o encerramento da RJ e depois outra decisão na qual ele mantém a decisão de convolar a RJ em falência

#nestes casos, acho que o mais prudente é usar a última decisão, pois pelo visto acontece o revertimento de um encerramento de recuperação judicial em uma falência. Então se pegarmos a última data, não teremos esse problema.

#teste
# final %>%
#   arrange(processo, data_final) %>%
#   filter(processo == final_duplicado[2]) %>%
#   slice(-1)


#pegando só a última data neste caso. Ordenei a data de maneira decrescente
final <- final %>% 
  arrange(processo, desc(data_final)) %>%
  group_by(processo) %>% 
  slice(1)

```



```{r datas_rj}

#vamos construir a tabela com todos os números de processo e a data de requerimento da RJ
#datas_rj ####
datas_rj <- primeira_mov %>% 
  select(processo, date) %>% 
  rename(data_requerimento = date)


#incorporando datas de homologação #### 
datas_rj <- datas_rj %>% 
  left_join(hom, by = "processo")



#incorporando data final do processo ####
datas_rj <- datas_rj %>% 
  left_join(final, by = "processo")






```


```{r checando casos com homologação NA}

#às vezes o plano de recuperação judicial não é homologado.
#pode ser que ele seja reprovado pelos credores, daí o juiz transforma (convola) a recuperação judicial em falência
#vou verificar se isso aconteceu com parte dos casos anteriores



#o juiz convola a RJ em falência a pedido dos credores usando o inciso iii do artigo 73
check_hom_convol <- datas_rj %>% 
  filter(is.na(data_hom)) %>% 
  rename(detalhes = detalhes_final) %>% #para eu poder usar a função procura()
  procura_resume("73, iii, | 73, inc. iii, | 73, inciso iii,")

#o juiz convola a RJ em falência quando usa o inciso ii quando a empresa não apresenta plano de recuperação 
check_hom_convol2 <- datas_rj %>% 
  filter(is.na(data_hom)) %>% 
  rename(detalhes = detalhes_final) %>% #para eu poder usar a função procura()
  procura_resume("73, ii, | 73, inc. ii, | 73, inciso ii,")

#nos dois casos acima, a "data de homologacao" passa a ser a data de encerramento da RJ
#vamos incorporar isso usando case_when()


pattern_73 <- c("73, iii | 73, inc(iso|.) iii | 73, ii | 73, inc(iso|.) ii")

datas_rj <- datas_rj %>% 
  mutate(data_hom = case_when(is.na(data_hom) & str_detect(detalhes_final, pattern_73) ~ data_final,
                              TRUE ~ data_hom))

#por fim, uma curiosidade: existem mais que citam artigo 73 inciso iii para convolar em falência mesmo quando já têm data de homologação do plano. Isso é esquisito, mas acontece quando o juiz aprova um plano forçadamente - usando cram down, passando por cima da decisão dos credores -, mas depois convola a rj em falência alegando que o plano não tinha sido aprovado pelos credores
datas_rj_73 <- datas_rj %>% 
  rename(detalhes = detalhes_final) %>% 
  procura_resume("73, iii, | 73, inc. iii, | 73, inciso iii,")




```


#### 6. Gerar pelo menos uma tabela bem formatada no relatório final



```{r estatísticas}
#vamos criar as estatísticas aqui


#vamos obter a quantidade de dias entre as duas datas
#depois vamos dividir a quantidade de dias por 30 para obter "meses"


#diferença entre requerimento e homologação

datas_rj <- datas_rj %>% 
  mutate(dias_req_hom = (data_hom - data_requerimento),
         meses_req_hom = dias_req_hom/30)


#checar datas inferiores a 30 dias - provável que tenha pego dados de deferimento ao invés de homologação
# datas_rj %>% 
#   filter(dias_req_hom <30)

#diferença entre requerimento e finalização da RJ
datas_rj <- datas_rj %>% 
  mutate(dias_req_final = (data_final - data_requerimento),
         meses_req_final = dias_req_final/30)



#diferença entre homologação e finalização da RJ
datas_rj <- datas_rj %>% 
  mutate(dias_hom_final = (data_final - data_hom),
         meses_hom_final = dias_hom_final/30)





```


O resultado dos dados encontrados está na tabela abaixo. 


```{r número de casos de NA}

na_hom <- datas_rj %>% filter(is.na(data_hom)) %>% nrow()

na_final <- datas_rj %>% filter(is.na(data_final)) %>% nrow()
  
na_hom_final <- datas_rj %>% filter(is.na(data_final) & is.na(data_hom)) %>% nrow()
```

O número de casos para os quais não sabemos a data de homologação é `r na_hom`.

O número de casos para os quais não sabemos a data de finalização do processo é `r na_final`.

E o número de casos para os quais não sabemos nem a data de homologação nem a data de finalização do processo é `r na_hom_final`.



```{r tabela bem formatada, results='asis'}


#o stargazer só faz estatísticas descritivas de dataframes
datas_rj_descr <- datas_rj %>% select(meses_req_final, meses_req_hom, meses_hom_final) %>% as.data.frame()

#transformando para numeric, do contrário a função summary não funciona bem
datas_rj_descr <- datas_rj_descr %>% 
  mutate_all(as.numeric)


colunas_descr <- c("Meses entre requerimento e final", "Meses entre requerimento e homologação", "Meses entre homologação e final")


datas_rj_descr %>% summary() %>% kable(digits = 2, align = "c", col.names = colunas_descr, caption = "Estatísticas Descritivas")


#desisti de usar stargazer porque ele não mostrava o número de observações NA
# stargazer(datas_rj_descr, type = "html")


```

Vemos que, por exemplo, pelo menos metade dos casos de recuperação judicial dessa amostra demoraram mais que 3 anos (40 meses) desde a data de requerimento até o encerramento do processo.

Repare que há um número negativo na coluna "Meses entre homologação e final". Isto se deve a uma classificação incorreta das datas. Preferi deixar no trabalho para mostrar que ainda preciso pensar em formas melhores de checar os dados, e qualquer sugestão para isso é bem vinda.

Outro dado interesante é a mediana dos meses entre o requerimento e a homologação. Pelo menos metade dos casos demora mais que 14 meses nesta fase, sendo que idealmente esse prazo não deveria ser superior a 6 meses. Casos com número de meses entre requerimento e homologação altos podem ser de casos que foram abandonados pela empresa que pediu a recuperação.


#### 7. Gerar pelo menos dois gráficos ou mapas bem formatados no relatório final

O primeiro gráfico é a densidade do número de meses entre o requerimento da recuperação judicial e o final do processo. Sim, existem casos que passam mais de 10 anos na corte antes de encerrarem. Na nossa amostra, a maioria dos casos demora até 6 anos para terminar.
```{r g1}

#gráfico de meses entre requerimento e final
#usei escala de 12 em 12 para facilitar a visualização dos dados em anos.
#o argumento binwidth = 12 dentro de geom_histogram() não funcionou como eu esperava

xmin <- datas_rj %>% pull(meses_req_final) %>% as.numeric() %>% min(na.rm = T) %>% floor()
xmax <- datas_rj %>% pull(meses_req_final) %>% as.numeric() %>% max(na.rm = T) %>% floor()

#testei histograma, porém preferi a densidade
# datas_rj %>% 
#   ggplot()+
#   geom_histogram(aes(x = meses_req_final), na.rm = T, fill = "blue", alpha = 0.3, color = "black") +
#   scale_x_continuous(aes(x = meses_req_final), breaks = seq(0, xmax, 12))+
#   ggtitle("Número de meses entre requerimento e data final do processo")+
#   theme(plot.title = element_text(hjust = 0.5, size = 11))+
#   ylab("Número de observações")+
#   xlab("Meses entre requerimento e data final")+
#   theme_economist_white(base_size = 8, base_family = "sans")
  
  
datas_rj %>% 
  ggplot(aes(x = meses_req_final))+
  geom_density(na.rm = T, fill = "blue", alpha = 0.3, color = "black") +
  scale_x_continuous(breaks = seq(0, xmax, 12))+
  xlab("Meses") +
  ggtitle("Número de meses entre requerimento e data final do processo")+
  ylab("Densidade")+
  theme_economist_white(base_size = 8, base_family = "sans", horizontal = F)+
  theme(plot.title = element_text(hjust = 0.5, size = 11))
  

```


Após o requerimento da recuperação judicial, o juiz suspende todas as cobranças contra a empresa pelo prazo de 180 dias. Neste período espera-se que a empresa apresente um plano de recuperação judicial e consiga apoio de seus credores. Então destacamos o prazo de 6 meses na linha tracejada no gráfico. Percebe-se que a minoria dos casos cai dentro desse prazo "ideal".



```{r g2}

#gráfico de meses entre requerimento e homologação
#usei escala de 12 em 12 para facilitar a visualização dos dados em anos.
#o argumento binwidth = 12 dentro de geom_histogram() não funcionou como eu esperava

xmin2 <- datas_rj %>% pull(meses_req_hom) %>% as.numeric() %>% min(na.rm = T) %>% floor()
xmax2 <- datas_rj %>% pull(meses_req_hom) %>% as.numeric() %>% max(na.rm = T) %>% floor()

  
datas_rj %>% 
  ggplot()+
  geom_density(aes(x = meses_req_hom), na.rm = T, fill = "blue", alpha = 0.3, color = "black") +
  scale_x_continuous(breaks = seq(0, xmax2, 12))+
  xlab("Meses") +
  geom_vline(aes(xintercept = 6), linetype="dashed", colour="red") +
  ggtitle("Número de meses entre requerimento e homologação do processo")+
  ylab("Densidade")+
  theme_economist_white(base_size = 8, base_family = "sans", horizontal = F) +
  theme(plot.title = element_text(hjust = 0.5, size = 11)) +
  xlab("Meses")




```

Após a homologação do plano, a empresa ainda passa um período de pelo menos dois anos sob supervisão judicial. Esse é o período mínimo antes que o juiz encerre o processo considerando a empresa recuperada de fato. Se o processo foi encerrado antes disso é porque a empresa não conseguiu cumprir seu plano de recuperação judicial, logo teve seu processo transformado em uma falência. A linha pontilhada agora destaca esse prazo de 24 meses. 



```{r g3}


#gráfico de meses entre requerimento e homologação
#usei escala de 12 em 12 para facilitar a visualização dos dados em anos.


xmin3 <- datas_rj %>% pull(meses_hom_final) %>% as.numeric() %>% min(na.rm = T) %>% floor()
xmax3 <- datas_rj %>% pull(meses_hom_final) %>% as.numeric() %>% max(na.rm = T) %>% floor()

  
datas_rj %>% 
  ggplot()+
  geom_density(aes(x = meses_hom_final), na.rm = T, fill = "blue",  alpha = 0.3, color = "black") +
  scale_x_continuous(breaks = seq(0, xmax3, 12))+
  xlab("Meses") +
  geom_vline(aes(xintercept = 24), linetype="dashed", colour="red") +
  ggtitle("Número de meses entre homologação e final do processo")+
  ylab("Densidade")+
  xlab("Meses")+
  theme_economist_white(base_size = 8, base_family = "sans", horizontal = F) +
  theme(plot.title = element_text(hjust = 0.5, size = 11))
  

#código in-line
n_hom_final <- datas_rj %>%
  filter(meses_hom_final > 0) %>% 
  nrow()


n_hom_final_24 <- datas_rj %>%
  filter(meses_hom_final > 0 & meses_hom_final < 24) %>% 
  nrow()


```


Visualmente, parece que mais de um terço dos casos possui menos de 24 meses entre homologação e finalização. De fato, considerando apenas os casos com número de meses superior a zero, temos um total de `r n_hom_final` casos, dos quais `r n_hom_final_24` se encerram antes de 24 meses. Isto significa que pelo menos `r round(100 * n_hom_final_24/n_hom_final, 2)`% dos casos nos quais os credores chegam a aprovar um plano de recuperação são transformados em falência porque a empresa não conseguiu cumprir com o plano.



#### 5. Incorporar pelo menos duas estatísticas resumidas no relatório final em In-line código

Incorporadas acima.

#### 8. Organizar e comentar o seu script para que seja claro o efeito de cada chunk e cada operação

Todos os chunks com EVAL = FALSE e INCLUDE = FALSE não precisam ser corrigidos. Eu deixei no código apenas para registrar as outras abordagens que eu cheguei antes do resultado final.

#### 9. Configurar os parâmetros dos chunks para gerar um relatório limpo e claro

#### 10. Submeter o seu script, e o documento final (HMTL/PDF)


#### 11. Checando quais casos têm dados estranhos

```{r casos com data de encerramento antes da homologação}

chec_hom_final <- datas_rj %>% 
  filter(meses_hom_final < 0 )

#caso com final 0539 a data final está ok, mas na verdade a homologação que foi errada
#caso 1001489-59.2017.8.26.0099 é estranho: teve a rj convolada em falência e depois o juiz permitiu que fizessem nova assembleia, aprovassem novo plano e aí homologou a rj. Mais seguro é só retirar esse caso da amostra


```



```{r meses até requerimento muito altos}
datas_rj %>% 
  filter(meses_req_hom > 36)
```

#### 12. Procurando dados que não encontramos antes

Parece melhor começar achando as datas de finalização dos processos. O texto das decisões de finalização pode conter detalhes sobre quando os planos foram homologados.
```{r processos sem data de finalização}

na_final <- datas_rj %>% 
  filter(is.na(data_final)) %>% 
  distinct(processo) %>% 
  left_join(movs_df)

na_final_lista <- datas_rj %>% 
  filter(is.na(data_final)) %>% 
  distinct(processo)


#detalhes sobre os 7 casos sem data de finalização: 4 têm erro de fato, 3 casos não foram encerrados (erro meu no input manual)

#0008645-88.2012.8.26.0100
#presente recuperacao judicial fora encerrada por sentença transitada em julgado
#4081
#4049 : movimento de baixa definitiva com encerramento do bienio
#4042: decretação, por sentença, do encerramento da recuperacao judicial

#0024997-87.2013.8.26.0100
#comentários sobre carta de arrematação, mas tá esquisito


#0133085-64.2009.8.26.0100
#173769: teve sua quebra decretada por este juízo
#decretação de falência não está digitalizada, aconteceu no dia 25/04/2018. Página 1858 do pdf do auto

#1008112-48.2015.8.26.0152
#ainda estava em andamento em 2019. A recuperação foi encerrada com êxito em 2020

#1012203-08.2016.8.26.0554
#empresa faliu antes de ter o plano homologado. Foi autofalência. Página 484

#1023746-04.2015.8.26.0114
#acho que ainda está em andamento também

#1025824-13.2015.8.26.0100
#acho que ainda está em andamento
#AJ pediu para encerrar a recuperação, credores discordaram e não tem movimento de encerramento até hoje
















#0017709-93.2010.8.26.0100
#ESAJ não publicou a decretação de falência



```


```{r conferindo dados do input_manual}

input_manual <- readRDS('outcomes_ze_matheus.RDS')


#checando processos que parecem estar em andamento


#1008112-48.2015.8.26.0152
#1023746-04.2015.8.26.0114
#1025824-13.2015.8.26.0100

#os três ainda estão em andamento, vou excluir da análise.



```




```{r processos sem data de homologação ou rejeição do plano}

na_hom <- datas_rj %>% 
  filter(is.na(data_hom)) %>% 
  distinct(processo) %>% 
  left_join(movs_df)

na_hom_lista <- datas_rj %>% 
  filter(is.na(data_hom)) %>% 
  distinct(processo) 

#filtro na base datas_rj para ver se aproveito texto dos casos que tiveram encerramento
na_hom_datasrj <- datas_rj %>% 
  filter(is.na(data_hom)) 


#1012203-08.2016.8.26.0554
#único processo que não tem data de homologação nem de finalização. Empresa faliu antes de ter processo homologado


#0001920-16.2010.8.26.0048
#169834
#autorizo a recueracao judicial de droga farma > deferimento da rj
#170073
#homologo o plano aprovado em assembleia de credores

#0000547-55.2014.8.26.0291
#225
#homologo, para que produza todos os efeitos de direito, o plano de recuperacao judicial substitutivo


#0013945-42.2012.8.26.0161
# detalhes_id_linha(179965)
#julgo procedente o pedido de convolacao da recuperacao judicial e decreto a falencia de \"andiaco laminados ltda.\", com fulcro no artigo 73



#0033994-59.2013.8.26.0100
#detalhes_id_linha(172880
#a convolacao da recuperacao judicial em falencia, objeto dos artigos 61, § 1º e 73, iv, ambos da lei n. 11.101/05. posto isso, nos termos do art. 73, inc. iv, da lei nº 11.101/05, convolo em falencia a recuperacao judicial da empresa pointh display materiais promocionais ltda.
## empresa que faliu antes de aprovar o plano de recuperação judicial
## como separar casos de falência do inciso iv quando a firma ainda não homologou plano?

#0036024-03.2012.8.26.0068
# detalhes_id_linha(19102)
#conforme ja determinado na sentenca de convolacao em falencia. fls. 2248/2249: providencie a administradora judicial a instauracao de incidente para analise dos balancos, devendo a falida apresentar esclarecimentos no referido incidente, a fim de se evitar tumulto procedimental.
#o art. 45, §1º da lrf
#pg 1815 foi decretada falência, em 14 de agosto de 2015


```

